
>локальная СКВ - разные версии кода хранятся в разным папках на компе разработчика
|разработчик - комп(версии)|
~ Утилита res..

>централизованная СКВ - разные версии кода храняться на сервере, все разработчики имеют доступ к серверу и работают с отдельными файлами проекта у себя на компе
|разработчик - файл на компе - сервер(версии)|
~ CVS, Perforce, Subversion..

>распределённая СКВ - разные версии кода хранятся на сервере, а так же и у разработчика на компе, все разработчики имеют доступ к серверу и работают со всем проектом(копии версий проектов на компе разработчика) у себя на компе
|разработчик - проект на компе (а так же все версии) - сервер(версии)|
~ Git, Mercurial, Bazaar, Darcs..


            -->Introduction to git<--

>хранение: {рис1}каждая новая версия - слепок, состоящий из уже видоизвенённых исходных файлов (вот только файлы, которые не были изменены, это ссылка на файл из прошлой версии)
~ {рис2}другие скв: набор исходных файлов и изменений, сделанных к этим файлам во времени

>целостность: у файлов есть идекс (контрольная сумма: SHA-1 хеш (строка из 40 16-х символов)), т.е. изменение информации всегда отслеживается по этому индексу

>ТРИ состояния: 
- зафиксированный { файл уже сохранён в вашей локальной базе } - файл, которые одинаков на компе и серваке
- изменённый { файлы, которые поменялись, но ещё не были зафиксированы } - файл на компе отличается от файла на серваке 
- подготовленный { изменённые файлы, отмеченные для включения в следующий коммит } - изменённый файл, который нужно отправить серваку

>{рис3}ТРИ части (в зависисмости от состояния): 
- каталог гита (git directory) {  это место, где Git хранит метаданные и базу данных объектов вашего проекта. Это наиболее важная часть Git'а, и именно она копируется, когда вы клонируете репозиторий с другого компьютера. }
- рабочий каталог (working directory) { это извлечённая из базы копия определённой версии проекта }
- область подготовленных файлов (staging area) { это обычный файл, обычно хранящийся в каталоге Git'а, который содержит информацию о том, что должно войти в следующий коммит }

//--
Стандартный рабочий процесс с использованием Git'а выглядит примерно так:

Вы вносите изменения в файлы в своём рабочем каталоге.
Подготавливаете файлы, добавляя их слепки в область подготовленных файлов.
Делаете коммит, который берёт подготовленные файлы из индекса и помещает их в каталог Git'а на постоянное хранение.
//--

>Пеовоначальная настройка git: (из git bush)
- утилита git config {просматривать и устанавливать параметры, контролирующие все аспекты работы Git'а и его внешний вид}
    - Файл /etc/gitconfig содержит значения, общие для всех пользователей системы и для всех их репозиториев. Если при запуске git config указать параметр --system, то параметры будут читаться и сохраняться именно в этот файл.
    - Файл ~/.gitconfig хранит настройки конкретного пользователя. Этот файл используется при указании параметра --global.
    - Конфигурационный файл в каталоге Git'а (.git/config) в том репозитории, где вы находитесь в данный момент. Эти параметры действуют только для данного конкретного репозитория. Настройки на каждом следующем уровне подменяют настройки из предыдущих уровней, то есть значения в .git/config перекрывают соответствующие значения в /etc/gitconfig.
- git config [--global] user.name "name" { настройка имени }
- git config [--global] user.email mymail@mail.my { настройка почты }
- git config [--global] core.editor emacs { настройка текстового редактора }
- git config [--global] merge.tool vimdiff { настройка разрешения конфликтов слияния }
-> и другие..
- git config --list { список настроек репозитория (ну естественно, если не настраивал, то берётся из --system или --global)}

> Как получить помощь?:
- git help <команда>
- git <команда> --help
- man git-<команда>


            -->Git basics<--

> Создания Git repository {два подхода: импорт в Git уже существующего проекта или каталога, клонирование уже существующего репозитория с сервера }
- первый:
    - {Создание репозитория в существующем каталоге}: 
        - git init { в каталоге проекта {  создаёт в текущем каталоге новый подкаталог с именем .git содержащий все необходимые файлы репозитория, На этом этапе ваш проект ещё не находится под версионным контролем }}
            - git add *.* {  проиндексировать эти файлы  }
            - git commit [-m] 'initial project version' { осуществить первую фиксацию изменений }  
            //--
            что делают эти команды Точнее разберём далее
            //--
- второй:
    - { Клонирование существующего репозитория }:
        - git clone url { получить копию существующего репозитория Git, url = git://github.com/schacon/grit.git or http(s)://.. or user@server:/path.git  }
        - git clone url name1 { клонирование в подкаталог name1 проекта *.git }

> Запись изменений в репозиторий:
//--
{рис4}
каждый файл в вашем рабочем каталоге может находиться в одном из двух состояний:
 под версионным контролем (отслеживаемые) { файлы, которые были в последнем слепке состояния проекта, они могут быть неизменёнными, изменёнными или подготовленными к коммиту }
 и нет (неотслеживаемые) { всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний слепок состояния и не подготовлены к коммиту }

Когда вы впервые клонируете репозиторий, все файлы будут отслеживаемыми и неизменёнными.

Как только вы отредактируете файлы, Git будет рассматривать их как изменённые, т.к. вы изменили их с момента последнего коммита.
Вы индексируете (git add) эти изменения и затем фиксируете (git commit) все индексированные изменения, а затем цикл повторяется.
//--
> определение состояния файлов:
    - git status { определение состояния файлов }
//--
{рис5}
сделал файл - неотслеживаемый
git add файл - отслеживаемый, неизменённый
изменяем содержимое файла
теперь файл - отслеживаемый, изменённый
git commit -m 'add text3' - после этого шага файл записан в слепок и помещён в git, теперь он неотслеживаемый

если 
то каталог, то индекстация идёт сразу по всем файлам внутри
//--
> игнорирование файлов:
    - { если даже в списке неотслеживаемых не хочу видеть}:
        - cat .gitignore [..] 
        {
            [..]:
            К шаблонам в файле .gitignore применяются следующие правила:
                -Пустые строки, а также строки, начинающиеся с #, игнорируются.
                -Можно использовать стандартные glob шаблоны.
                -Можно заканчивать шаблон символом слэша (/) для указания каталога.
                
            Можно инвертировать шаблон, использовав восклицательный знак (!) в качестве первого символа.
            Glob-шаблоны представляют собой упрощённые регулярные выражения используемые командными интерпретаторами.
             Символ * соответствует 0 или более символам;
             последовательность [abc] — любому символу из указанных в скобках (в данном примере a, b или c);
             знак вопроса (?) соответствует одному символу;
             [0-9] соответствует любому символу из интервала (в данном случае от 0 до 9).

             ~ 
             {
                 # комментарий — эта строка игнорируется
                 # не обрабатывать файлы, имя которых заканчивается на .a
                 *.a
                 # НО отслеживать файл lib.a, несмотря на то, что мы игнорируем все .a файлы с помощью предыдущего правила
                 !lib.a
                 # игнорировать только файл TODO находящийся в корневом каталоге, не относится к файлам вида subdir/TODO
                 /TODO
                 # игнорировать все файлы в каталоге build/
                 build/
                 # игнорировать doc/notes.txt, но не doc/server/arch.txt
                 doc/*.txt
                 # игнорировать все .txt файлы в каталоге doc/
                 doc/**/*.txt
             }
        }
> Просмотр индексированных и неиндексированных изменений (что именно поменялось в файле?):
    - git diff { показывает добавленные и удалённые строки, к примеру, подробнее о команде дальше.. }
> Фиксация изменений:
    - git commit [-m '..'] { если -m нет, тогда откроется текстовый редактор и вводим комент (внутри уже есть выхлоп #..), если есть -m то комент записывается в 'meComment' и это добавляется в выхлопу () }
> Игнорирование индексации:
    - git commit -a { файлы, которые были изменены, но не add так же пойдут в коммит}
> Удаление файлов:
//--
для удаления файлов из гита, нужно удалить его из отслеживаемых и провести коммит
//--
    - git rm name { удаление файла из отслеживаемых(также удалит и в реале) } 
//--
если файл просто удалить ручками, то он будет помечен в секции Changes not staged for commit
затем если git rm, то удаление файла попадёт в индекс
далее комми и файл исчезнет навсегда и не будет отслеживается :)
//--
если файл изменили, проиндесировали, удалили его ручками
то что бы удалить его из индесации нужно: параметр -f  (git rm -f name)
//--
удалить файл из индекса, НО оставив на диске, как неотслеживаемый: --cached (git rm --cached name)
//--
можно кидать не ися файла, а шаблом => удаление всех файлов подходящих шаблону (git rm \шаблон) 
//--
> Перемещение/переименование
    - git mv newname[or новый путь [newname]] 


             -->Viewing the history of commits<--

> Просмотр истории коммитов:
    - git log 
    { выводит историю коммитов (первый в списке - последний в истории)
        {
            Куча разных параметров для вывода => https://git-scm.com/book/ru/v1/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%9F%D1%80%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D0%BE%D0%B2
            так же графическое наблюдение, команда: gitk
        }    
    } 


             -->Сancellation of changes<--

> Изменение последнего коммита:
    - git commit --amed { берёт последний коммит и добавляет к нему то, 'что забыл сделать' }
> Отмена индексации файла:
//--
add f1
add f2
ой, а f2 не хотелось 
тогда 
git reset HEAD f2
теперь f2 снова изменён, но уже не под индексом
//--
f1
измениои содержимое f1 
ой, а я не хотел менять f1
тогда
git checkout -- f1
ВСЁ, теперь f1 в первичном состоянии 
//--


             -->Working with remote repositories<--

> Отображение удалённых репозиториев:
    - git remote [-v] { перечисляет список имён-сокращений для всех уже указанных удалённых дескрипторов { Чтобы посмотреть, какому URL соответствует сокращённое имя в Git, можно указать команде опцию -v } }
> Добавление удалённых репозиториев:
    - git remote add [сокращение] [url] 
      {   ~
          {
              $ git remote
              origin
              $ git remote add pb git://github.com/paulboone/ticgit.git
              $ git remote -v
              origin  git://github.com/schacon/ticgit.git
              pb  git://github.com/paulboone/ticgit.git
          }
          ~
          {
              Теперь вы можете использовать в командной строке имя pb вместо полного URL.
               Например, если вы хотите извлечь (fetch) всю информацию, которая есть в репозитории Павла, но нет в вашем, вы можете выполнить git fetch pb:
               $ git fetch pb
               remote: Counting objects: 58, done.
               remote: Compressing objects: 100% (41/41), done.
               remote: Total 44 (delta 24), reused 1 (delta 0)
               Unpacking objects: 100% (44/44), done.
               From git://github.com/paulboone/ticgit
                * [new branch]      master     -> pb/master
                * [new branch]      ticgit     -> pb/ticgit
              Ветка master Павла теперь доступна локально как pb/master. Вы можете слить (merge) её в одну из своих веток или перейти на эту ветку, если хотите её проверить.
          }
 > Fetch and Pull:
    - git fetch [имя удал. сервера] { для получения данных из удалённых проектов }
    - git pull [имя удал. сервера] { автоматически извлекает и затем сливает данные из удалённой ветки в вашу текущую ветку }
> Push:
    - git push [удал. сервер] [ветка] { отправить }
> Инспекция удалённого репозитория:
    - git remote show [удал. сервер] { получить побольше информации об одном из удалённых репозиториев }
> Удаление и переименование удалённых репозиториев:
    - git remote rename n1 n2 { Для переименования сокращённого имени, используемого для удалённого репозитория }
    - git remote rm n1 { удалить ссылку (вы сменили сервер или больше не используете определённое зеркало, или, возможно, контрибьютор перестал быть активным) }


             -->Working with labels<--

> Просмотр меток:
    - git tag  { Просмотр меток, Алфавитный порядок }
    - git tag [-l шаблон] { Просмотр меток по заданному шаблону, Алфавитный порядок}
> Создание меток:
//--
типы меток:
легковесные { что-то весьма похожее на ветку, которая не меняется — это просто указатель на определённый коммит }
аннотированные { аннотированные метки хранятся в базе данных Git'а как полноценные объекты. Они имеют контрольную сумму, содержат имя поставившего метку, e-mail и дату, имеют комментарий и могут быть подписаны и проверены с помощью GNU Privacy Guard (GPG) } 
//--
    - Аннотированные метки:
        - git tag -a name [-m 'text'] 
    - Легковесные метки:
        - git tag name { В сущности, это контрольная сумма коммита, сохранённая в файл — больше никакой информации не хранится }

    - <Подписанные метки>:
        - git tag -s name [-m 'text']     
            - git show name { посмотреть данные метки вместе с коммитом, который был помечен }
 
> Верификация меток:
    - git tag -v [имя метки] { Для верификации подписанной метки, команда использует GPG для верификации подписи. Вам нужен открытый ключ автора подписи, чтобы команда работала правильно }
> Выставление меток позже:
    - git tag -a name -m 'test' 9fceb02 { помечать уже пройденные коммиты, 9..2 - контрольная сумма той версии, которую следует пометить }
> Обмен метками: 
//--
По умолчанию, команда git push не отправляет метки на удалённые серверы.
 Необходимо явно отправить (push) метки на общий сервер после того, как вы их создали.
    - git push [url] [имя метки] 
Если у вас есть много меток, которые хотелось бы отправить все за один раз, можно использовать опцию --tags
    - git push [url] --tags
//--


             -->Полезные советы<--
//--
..
//--
